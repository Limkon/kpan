<%# views/edit-file.ejs %>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编辑文件: <%= filename %></title>
    <link rel="stylesheet" href="/style.css">
    <link id="theme-stylesheet" rel="stylesheet" href="">

    <style>
        /* --- General Layout --- */
        html, body {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
        }

        .container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            max-width: 98%;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }

        form {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* --- [FIX] Header Layout --- */
        .editor-header {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap; /* Prevent wrapping */
            gap: 20px;
        }
        
        .editor-header h2 {
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0; /* Important for ellipsis in flexbox */
            flex-grow: 1; /* Allow title to take available space */
        }
        
        .editor-header .button-link {
            flex-shrink: 0; /* Prevent button from shrinking */
        }


        .editor-actions {
            margin-top: 15px;
            text-align: right;
            flex-shrink: 0;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .button-link {
            display: inline-block;
            padding: 8px 12px;
            background-color: #6c757d;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: nowrap;
        }
        .button-link:hover {
            background-color: #5a6268;
        }

        /* --- Custom Code Editor --- */
        .code-editor-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            border: 1px solid #ced4da;
            border-radius: 5px;
            overflow: hidden;
            background-color: #ffffff;
        }

        .line-numbers {
            flex-shrink: 0;
            padding: 10px 8px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #888;
            background-color: #f7f7f7;
            text-align: right;
            border-right: 1px solid #ddd;
            user-select: none;
            overflow: hidden;
        }

        .editor-main {
            position: relative;
            flex-grow: 1;
            overflow: auto; /* Required for scroll syncing */
        }
        
        .editor-main textarea,
        .editor-main pre {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            border: none;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre;
            word-wrap: normal;
            overflow-wrap: normal;
            background: transparent; /* Both are transparent */
        }

        .editor-main textarea {
            z-index: 1;
            color: transparent; /* Makes the textarea text invisible */
            caret-color: #333; /* But keeps the caret visible */
            resize: none;
            outline: none;
        }

        .editor-main pre {
            z-index: 0;
            pointer-events: none; /* Allows clicks to go through to the textarea */
            overflow: hidden; 
        }
        
        .editor-main pre code {
            display: block;
        }

        /* --- Syntax Highlighting Styles --- */
        pre .token-comment { color: #6a9955; }
        pre .token-string { color: #ce9178; }
        pre .token-keyword { color: #569cd6; font-weight: bold; }
        pre .token-number { color: #b5cea8; }
        pre .token-boolean { color: #569cd6; }
        pre .token-function { color: #dcdcaa; }
        pre .token-tag { color: #4ec9b0; }
        pre .token-attribute { color: #9cdcfe; }
        pre .token-value { color: #ce9178; }
        pre .token-operator { color: #d4d4d4; }
        pre .token-punctuation { color: #d4d4d4; }
        pre .token-selector { color: #d7ba7d; }
        pre .token-property { color: #9cdcfe; }

        /* --- Dark Theme Adjustments --- */
        body.dark-theme {
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        .dark-theme .button-link {
            background-color: #5a6268;
            color: #e0e0e0;
        }
        .dark-theme .button-link:hover {
             background-color: #6c757d;
        }
        .dark-theme .code-editor-wrapper {
            border-color: #555;
            background-color: #1e1e1e;
        }
        .dark-theme .line-numbers {
            background-color: #252526;
            color: #858585;
            border-right: 1px solid #333;
        }
        .dark-theme .editor-main textarea {
            caret-color: #aeafad;
        }
        
        .dark-theme pre .token-operator,
        .dark-theme pre .token-punctuation {
            color: #d4d4d4;
        }
        .dark-theme pre .token-tag { color: #4ec9b0; }
        .dark-theme pre .token-attribute { color: #9cdcfe; }
        .dark-theme pre .token-string { color: #ce9178; }
    </style>
</head>
<body class="<%= locals.theme === 'dark' ? 'dark-theme' : '' %>">

    <div class="container">
        <% if (message) { %>
            <div class="message <%= messageType === 'error' ? 'error-message' : '' %>">
                <%= message %>
            </div>
        <% } %>

        <div class="editor-header">
             <h2>正在编辑: <%= filename %></h2>
              <% const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/')) || '/'; %>
              <a href="/files?path=<%= encodeURIComponent(parentPath) %><%= viewTargetUsername ? '&targetUsername=' + encodeURIComponent(viewTargetUsername) : '' %>" class="button-link">&larr; 返回文件列表</a>
        </div>

        <form action="/save/<%= encodeURIComponent(currentPath) %>" method="post">
            <input type="hidden" name="_csrf" value="<%= csrfToken %>">
            <% if (viewTargetUsername) { %>
                <input type="hidden" name="targetUsername" value="<%= viewTargetUsername %>">
            <% } %>
            
            <div class="code-editor-wrapper">
                <div class="line-numbers" id="line-numbers-display">1</div>
                <div class="editor-main">
                    <textarea id="fileContent" name="fileContent" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"><%- content %></textarea>
                    <pre id="highlight-output" aria-hidden="true"><code></code></pre>
                </div>
            </div>

            <div class="editor-actions">
                <button type="submit">保存更改</button>
                <% const viewUrl = `/view?path=${encodeURIComponent(currentPath)}${viewTargetUsername ? '&targetUsername=' + encodeURIComponent(viewTargetUsername) : ''}`; %>
                <button type="button" class="secondary" onclick="window.location.href='<%= viewUrl %>'">取消</button>
            </div>
        </form>
    </div>
    
    <script src="/theme.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const textarea = document.getElementById('fileContent');
        const highlightOutput = document.getElementById('highlight-output');
        const highlightCodeEl = highlightOutput.querySelector('code');
        const lineNumbersDisplay = document.getElementById('line-numbers-display');
        const filename = "<%= filename %>";

        const escapeHtml = (text) => {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        };

        const getLanguageFromFilename = (name) => {
            const ext = name.split('.').pop().toLowerCase();
            if (['js', 'mjs', 'cjs', 'json'].includes(ext)) return 'javascript';
            if (['css'].includes(ext)) return 'css';
            if (['html', 'htm', 'xml'].includes(ext)) return 'html';
            return 'plaintext'; // Default
        };
        
        const language = getLanguageFromFilename(filename);

        const highlight = (text, lang) => {
            if (lang === 'plaintext') {
                return escapeHtml(text);
            }

            let escapedText = escapeHtml(text);
            
            // This is a very basic highlighter, not a full parser.
            const rules = {
                javascript: [
                    { type: 'comment', regex: /(\/\/.*|\/\*[\s\S]*?\*\/)/g },
                    { type: 'string', regex: /(".*?"|'.*?'|`.*?`)/gs },
                    { type: 'keyword', regex: /\b(const|let|var|if|else|for|while|return|function|class|import|export|from|async|await|new|this|typeof|instanceof)\b/g },
                    { type: 'boolean', regex: /\b(true|false|null|undefined)\b/g },
                    { type: 'number', regex: /\b(\d+(\.\d+)?)\b/g },
                    { type: 'function', regex: /(\w+)(?=\s*\()/g },
                    { type: 'operator', regex: /([+\-*/%=&|<>!^~?:])/g },
                    { type: 'punctuation', regex: /([{}()[\].,;])/g }
                ],
                html: [
                    { type: 'comment', regex: /(&lt;!--[\s\S]*?--&gt;)/g },
                    { type: 'tag', regex: /(&lt;\/?[\w\d-]+|&gt;)/g },
                    { type: 'attribute', regex: /(\s+[\w\d-]+)(?=\s*=)/g },
                    { type: 'string', regex: /(".*?"|'.*?')/g }
                ],
                css: [
                    { type: 'comment', regex: /(\/\*[\s\S]*?\*\/)/g },
                    { type: 'string', regex: /(".*?")/g },
                    { type: 'selector', regex: /(^|[\s,}{])([.#&]?[a-zA-Z0-9\-_*:]+)(?=[^}]*\{)/g },
                    { type: 'property', regex: /([\w-]+)(?=\s*:)/g },
                    { type: 'number', regex: /(-?\d*\.?\d+)(px|%|em|rem|vw|vh|s)?/g },
                ]
            };
            
            const langRules = rules[lang] || [];
            if (langRules.length === 0) return escapedText;

            // This approach is simplified and may not be perfect, but avoids complex lookaheads.
            // It replaces text outside of existing spans.
            let result = '';
            let lastIndex = 0;
            const combinedRegex = new RegExp(langRules.map(r => r.regex.source).join('|'), 'g');
            
            escapedText.replace(combinedRegex, (match, ...args) => {
                const offset = args[args.length - 2];
                // Find which rule matched
                let ruleType = 'unknown';
                for(let i = 0; i < langRules.length; i++){
                    // Re-test the match with each rule's regex
                     if(new RegExp(`^${langRules[i].regex.source}$`).test(match)){
                        ruleType = langRules[i].type;
                        break;
                     }
                }
                 // Add the text before the match
                result += escapedText.substring(lastIndex, offset);
                // Add the highlighted match
                result += `<span class="token-${ruleType}">${match}</span>`;
                // Update the last index
                lastIndex = offset + match.length;
            });

            // Add any remaining text
            result += escapedText.substring(lastIndex);
            
            return result;
        };

        const updateEditor = () => {
            const code = textarea.value;
            
            const highlightedCode = highlight(code, language);
            highlightCodeEl.innerHTML = highlightedCode + '\n'; // Add trailing newline for better rendering of last line

            // Update line numbers
            const lineCount = code.split('\n').length || 1;
            const lines = Array.from({ length: lineCount }, (_, i) => i + 1).join('\n');
            lineNumbersDisplay.textContent = lines;

            // Sync scrolling
            syncScroll();
        };

        const syncScroll = () => {
            if(!textarea || !highlightOutput || !lineNumbersDisplay) return;
            highlightOutput.scrollTop = textarea.scrollTop;
            highlightOutput.scrollLeft = textarea.scrollLeft;
            lineNumbersDisplay.style.transform = `translateY(-${textarea.scrollTop}px)`;
        };

        const handleTab = (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                
                const tabCharacter = '  '; // 2 spaces for tab
                
                // For multi-line selection
                if (start !== end && textarea.value.substring(start, end).includes('\n')) {
                    const selectedLines = textarea.value.substring(start, end).split('\n');
                    const indentedText = selectedLines.map(line => e.shiftKey ? line.startsWith(tabCharacter) ? line.substring(2) : line : tabCharacter + line).join('\n');
                    textarea.value = textarea.value.substring(0, start) + indentedText + textarea.value.substring(end);
                    textarea.selectionStart = start;
                    textarea.selectionEnd = start + indentedText.length;
                } else {
                    // Single line or no selection
                    textarea.value = textarea.value.substring(0, start) + tabCharacter + textarea.value.substring(end);
                    textarea.selectionStart = textarea.selectionEnd = start + tabCharacter.length;
                }
                updateEditor();
            }
        };

        textarea.addEventListener('input', updateEditor);
        textarea.addEventListener('scroll', syncScroll);
        textarea.addEventListener('keydown', handleTab);
        
        // Initial load
        updateEditor();
    });
    </script>
</body>
</html>
